<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Practice Round Robin ‚Äî Multi-Category (With Doubles)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #e8eef7;
        --card: #ffffff;
        --panel-2: #f5f8ff;
        --text: #203347;
        --muted: #5b6b7a;
        --accent: #355caa;
        --primary: #4b6cb7;
        --win: #16a34a;
        --loss: #ef4444;
        --neutral: #7b88a8;
        --radius: 14px;
        --shadow-light: 9px 9px 20px rgba(163, 177, 198, 0.55),
          -9px -9px 20px rgba(255, 255, 255, 0.9);
        --shadow-inset: inset 4px 4px 8px rgba(0, 0, 0, 0.08),
          inset -4px -4px 8px rgba(255, 255, 255, 0.8);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
        background: var(--bg);
        color: var(--text);
        transition: background 0.3s, color 0.3s;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 5;
        padding: 12px 14px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        background: var(--card);
        border-radius: var(--radius);
        box-shadow: var(--shadow-light);
      }
      h1 {
        margin: 0 6px 0 0;
        font-size: 18px;
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      input,
      textarea,
      select,
      button {
        padding: 6px 10px;
        border-radius: 10px;
        border: none;
        background: var(--card);
        color: var(--text);
        box-shadow: var(--shadow-inset);
      }
      textarea {
        width: 220px;
        height: 60px;
      }
      button {
        cursor: pointer;
        box-shadow: var(--shadow-light);
      }
      button.primary {
        background: linear-gradient(145deg, var(--primary), var(--accent));
        color: #fff;
      }
      main {
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 14px;
        padding: 14px;
      }
      .board,
      aside {
        border-radius: var(--radius);
        background: var(--card);
        padding: 14px;
        box-shadow: var(--shadow-light);
      }
      aside {
        position: sticky;
        top: 82px;
        height: calc(100vh - 110px);
        overflow: auto;
      }
      table.matches,
      table.stats {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
      }
      table.matches th,
      table.matches td,
      table.stats th,
      table.stats td {
        border: 1px solid rgba(0, 0, 0, 0.05);
        padding: 6px 8px;
        font-size: 13px;
      }
      table.matches th,
      table.stats th {
        background: var(--panel-2);
        color: var(--muted);
      }
      #playerSidebar {
        position: fixed;
        top: 15%;
        left: 0;
        height: 70%;
        width: 260px;
        background: var(--card);
        border-radius: 0 12px 12px 0;
        overflow-y: auto;
        box-shadow: var(--shadow-light);
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        z-index: 150;
        padding: 12px;
      }
      #playerSidebar.active {
        transform: translateX(0);
      }
      @media (max-width: 768px) {
        #playerSidebar {
          top: 0;
          left: 0;
          width: 80%;
          height: 100%;
          border-radius: 0 12px 12px 0;
        }
      }
      #sidebarOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.4);
        z-index: 140;
      }
      #sidebarOverlay.active {
        display: block;
      }
      .player-card {
        background: var(--panel-2);
        border-radius: 12px;
        padding: 10px;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        transition: transform 0.2s;
        box-shadow: var(--shadow-light);
      }
      .player-card:hover {
        transform: translateY(-2px);
      }
      .player-card img {
        width: 38px;
        height: 38px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid var(--accent);
      }
      #toggleHeaderBtn {
        position: fixed;
        bottom: 10px;
        right: 10px;
        z-index: 200;
        background: linear-gradient(90deg, var(--accent), var(--win));
        border: none;
        border-radius: 8px;
        padding: 6px 12px;
        color: #fff;
        font-size: 14px;
        cursor: pointer;
        box-shadow: var(--shadow-light);
      }
      .round-header {
        background: var(--panel-2);
        font-weight: bold;
        text-align: left;
      }
      @media (max-width: 768px) {
        main {
          display: block;
        }
        .board,
        aside {
          width: 100%;
          margin-bottom: 14px;
          height: auto;
        }
        table.matches,
        table.stats {
          font-size: 11px;
          width: 100%;
          table-layout: fixed;
        }
        table.matches th,
        table.matches td,
        table.stats th,
        table.stats td {
          padding: 3px 4px;
          word-wrap: break-word;
          white-space: normal;
        }
        table.matches input[type="number"] {
          width: 40px;
          font-size: 11px;
          padding: 2px;
        }
        table.matches button {
          font-size: 11px;
          padding: 3px 6px;
        }
      }
      #menuTabs {
        display: flex;
        gap: 8px;
        padding: 10px;
        background: var(--card);
        border-bottom: 2px solid var(--panel-2);
        position: sticky;
        top: 0;
        z-index: 300;
      }
      #menuTabs button {
        flex: 1;
        padding: 10px;
        border: none;
        border-radius: 8px;
        background: var(--panel-2);
        cursor: pointer;
        font-weight: bold;
      }
      #menuTabs button.active {
        background: var(--accent);
        color: #fff;
      }
      .hidden {
        display: none !important;
      }
      #allStatsTab {
        padding: 14px;
      }
      #allStatsTab table.stats {
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow-light);
        margin: 0 auto;
        width: calc(100% - 20px);
        margin-bottom: 3px;
      }
      .popup {
        display: none;
        position: fixed;
        top: 100px;
        left: 100px;
        width: 320px;
        background: var(--card);
        border-radius: 12px;
        box-shadow: var(--shadow-light);
        z-index: 500;
      }
      .popup-header {
        cursor: move;
        background: var(--accent);
        color: #fff;
        padding: 8px;
        border-radius: 12px 12px 0 0;
        display: flex;
        justify-content: space-between;
      }
      .popup-body {
        padding: 10px;
        max-height: 400px;
        overflow-y: auto;
      }
      .folder-link {
        cursor: pointer;
        color: var(--accent);
        font-weight: 600;
      }
      .folder-link:hover {
        text-decoration: underline;
      }
      #folderList {
        list-style: none;
        padding: 0;
        margin: 8px 0;
      }
      #folderList li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: var(--panel-2);
        padding: 6px 10px;
        margin-bottom: 6px;
        border-radius: 8px;
        box-shadow: var(--shadow-light);
      }
      #folderList li span {
        font-weight: 600;
        color: var(--accent);
        cursor: pointer;
      }
      #folderList li button {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 14px;
        padding: 2px 6px;
        border-radius: 6px;
      }
      #folderList li button:hover {
        background: #f8d7da;
      }
    </style>
  </head>
  <body>
    <nav id="menuTabs">
      <button data-tab="tournamentTab" class="active">üèÜ Tournament</button>
      <button data-tab="allStatsTab">üìä All Stats</button>
      <button data-tab="playersTab">üë• Players</button>
    </nav>
    <button id="toggleHeaderBtn">Hide Header</button>

    <div id="tournamentTab" class="tabContent">
      <header>
        <h1>Tournament-Round Robin</h1>

        <div class="controls">
          <label>Category</label>
          <select id="categorySelect">
            <option>U11</option>
            <option>U13</option>
            <option>U15</option>
            <option>U17</option>
            <option>U19</option>
            <option>Men</option>
            <option>Women</option>
            <option>Batch1</option>
            <option>Batch2</option>
            <option>Batch3</option>
            <option>Batch4</option>
            <option>Batch5</option>
          </select>

          <div class="category-nav" style="margin: 10px 0">
            <button id="prevCategoryBtn">‚¨ÖÔ∏è Prev Category</button>
            <button id="nextCategoryBtn">‚û°Ô∏è Next Category</button>
          </div>

          <label id="genderLabel">Gender</label>
          <select id="genderSelect">
            <option>Boys</option>
            <option>Girls</option>
          </select>

          <span id="currentKeyTag" class="legend"></span>
        </div>

        <div class="controls">
          <label>Match Type</label>
          <select id="matchType">
            <option value="Singles">Singles</option>
            <option value="Doubles">Doubles (manual)</option>
            <option value="Auto-Doubles">
              Auto-Doubles (pair automatically)
            </option>
          </select>
          <small style="align-self: center; color: #5b6b7a"
            >Auto-Doubles pairs players 1+2,3+4...</small
          >
        </div>

        <div class="controls">
          <input id="playerName" placeholder="Player name" />
          <button class="btn" id="addBtn">Add</button>

          <textarea id="bulk" placeholder="Bulk add (one per line)"></textarea>
          <button class="btn" id="bulkBtn">Bulk Add</button>
          <button class="btn" id="clearBtn">Clear Players</button>

          <span class="legend" id="count">0 players</span>
        </div>

        <div class="controls">
          <button class="btn primary" id="buildBtn">Generate Matches</button>
          <button class="btn" id="resetBtn">Reset Matches</button>
          <button class="btn" id="resetAllBtn">Reset All Categories</button>
          <button class="btn" id="clearAllBtn">Clear All Categories</button>
          <button class="btn" id="printBtn">Print</button>

          <button class="btn" id="exportBtn">Export (All)</button>
          <input
            type="file"
            id="importFile"
            accept="application/json"
            style="display: none"
          />
          <button class="btn" id="importBtn">Import (All)</button>

          <button class="btn" id="togglePlayersBtn">Players Sidebar</button>
        </div>

        <div class="controls">
          <label
            ><input type="checkbox" id="randomizeBeforeBuild" /> Randomize
            before build</label
          >
          <button class="btn" id="sampleBtn">Load Sample Data</button>
        </div>
      </header>

      <div id="playerSidebar">
        <div id="playerList"></div>
      </div>
      <div id="sidebarOverlay"></div>

      <main>
        <div class="board">
          <h2 id="matchesTitle">Matches</h2>
          <div class="table-container">
            <table class="matches" id="matchesTable"></table>
          </div>
        </div>

        <aside>
          <div class="table-container">
            <h3>Stats</h3>
            <table class="stats">
              <thead id="statsHead">
                <tr>
                  <th>#</th>
                  <th>Name</th>
                  <th>P</th>
                  <th class="win">W</th>
                  <th class="loss">L</th>
                  <th>PF</th>
                  <th>PA</th>
                  <th>¬±</th>
                </tr>
              </thead>
              <tbody id="statsBody"></tbody>
            </table>
          </div>
          <div id="playerDetails" class="card" style="margin-top: 12px">
            <p>Select a player from the sidebar‚Ä¶</p>
          </div>
          <div id="savedTournaments">
            <h3 id="folderToggle" style="cursor: pointer">
              üìÇ Saved Tournaments
            </h3>
            <button id="saveFolderBtn">Save Current Tournament</button>
            <button id="saveAllBtn">Save ALL Tournaments</button>

            <ul id="folderList" style="display: none"></ul>
          </div>
          <!-- Popup -->
          <div id="folderPopup" class="popup">
            <div class="popup-header">
              <span id="popupTitle">Tournament</span>
              <button onclick="closeFolderPopup()">‚ùå</button>
            </div>
            <div class="popup-body" id="popupContent"></div>
          </div>
        </aside>
      </main>
    </div>

    <div id="allStatsTab" class="tabContent" style="display: none">
      <h2>All Stats (All Categories)</h2>
      <table class="stats">
        <thead>
          <tr>
            <th>Category</th>
            <th>#</th>
            <th>Player / Team</th>
            <th>P</th>
            <th>W</th>
            <th>L</th>
            <th>PF</th>
            <th>PA</th>
            <th>¬±</th>
          </tr>
        </thead>
        <tbody id="allStatsBody"></tbody>
      </table>
    </div>

    <div id="playersTab" class="tabContent" style="display: none">
      <h2>Players List</h2>
      <div id="globalPlayerList"></div>
    </div>

    <div
      id="playerPopup"
      style="
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        align-items: center;
        justify-content: center;
        z-index: 300;
      "
    >
      <div
        style="
          background: var(--card);
          padding: 20px;
          border-radius: 16px;
          width: 360px;
          box-shadow: var(--shadow-light);
        "
      >
        <div style="text-align: center; margin-bottom: 12px">
          <img
            id="popupPhoto"
            src="default.png"
            alt="Player Photo"
            style="
              width: 100px;
              height: 100px;
              border-radius: 50%;
              border: 3px solid var(--accent);
              margin-bottom: 10px;
              object-fit: cover;
            "
          />
          <input type="file" id="popupPhotoInput" accept="image/*" />
        </div>
        <div style="display: flex; flex-direction: column; gap: 8px">
          <input id="popupName" placeholder="Name" />
          <input id="popupAge" type="number" placeholder="Age" />
          <input id="popupCountry" placeholder="Country" />
          <input id="popupAadhar" placeholder="Aadhar" />
          <textarea id="popupBio" rows="3" placeholder="Bio"></textarea>
        </div>
        <div
          style="
            margin-top: 12px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
          "
        >
          <button
            id="popupSaveBtn"
            style="
              flex: 1;
              padding: 6px 12px;
              border: none;
              border-radius: 8px;
              background: linear-gradient(
                145deg,
                var(--primary),
                var(--accent)
              );
              color: #fff;
            "
          >
            Save
          </button>
          <button
            onclick="closePlayerPopup()"
            style="
              flex: 1;
              padding: 6px 12px;
              border: none;
              border-radius: 8px;
              background: #ccc;
            "
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <script>
      (function () {
        try {
          const TOURNAMENTS = {};
          const q = (id) => document.getElementById(id);
          const esc = (s) =>
            String(s).replace(
              /[&<>"']/g,
              (m) =>
                ({
                  "&": "&amp;",
                  "<": "&lt;",
                  ">": "&gt;",
                  '"': "&quot;",
                  "'": "&#39;",
                }[m])
            );
          const on = (el, evt, fn) => el && el.addEventListener(evt, fn);

          const categorySelect = q("categorySelect");
          const genderSelect = q("genderSelect");
          const genderLabel = q("genderLabel");
          const currentKeyTag = q("currentKeyTag");
          const matchTypeSel = q("matchType");

          const playerName = q("playerName");
          const addBtn = q("addBtn");
          const bulk = q("bulk");
          const bulkBtn = q("bulkBtn");
          const clearBtn = q("clearBtn");
          const count = q("count");

          const buildBtn = q("buildBtn");
          const resetBtn = q("resetBtn");
          const printBtn = q("printBtn");
          const exportBtn = q("exportBtn");
          const importBtn = q("importBtn");
          const importFile = q("importFile");
          const randomizeCheckbox = q("randomizeBeforeBuild");
          const sampleBtn = q("sampleBtn");

          const togglePlayersBtn = q("togglePlayersBtn");
          const playerSidebar = q("playerSidebar");
          const playerList = q("playerList");

          const matchesTable = q("matchesTable");
          const statsBody = q("statsBody");
          const matchesTitle = q("matchesTitle");

          const DB_NAME = "TournamentDB";
          const DB_STORE = "tournaments";
          let db;

          const GLOBAL_DB_NAME = "PlayerDB";
          const GLOBAL_STORE = "players";

          function shuffleArray(arr) {
            const a = arr.slice();
            for (let i = a.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
          }

          async function openGlobalDB() {
            return new Promise((resolve, reject) => {
              const req = indexedDB.open(GLOBAL_DB_NAME, 1);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(GLOBAL_STORE)) {
                  db.createObjectStore(GLOBAL_STORE, { keyPath: "id" });
                }
              };
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });
          }

          const categories = [
            "U11-Boys",
            "U11-Girls",
            "U13-Boys",
            "U13-Girls",
            "U15-Boys",
            "U15-Girls",
            "U17-Boys",
            "U17-Girls",
            "U19-Boys",
            "U19-Girls",
            "Men",
            "Women",
            "Batch1",
            "Batch2",
            "Batch3",
            "Batch4",
            "Batch5",
          ];

          function keyFrom(cat, gen) {
            const isU = /^U\d+$/i.test(cat);
            return isU ? `${cat}-${gen}` : cat;
          }
          function getKey() {
            return keyFrom(
              categorySelect?.value || "U11",
              genderSelect?.value || "Boys"
            );
          }

          function getState() {
            const k = getKey();
            if (!TOURNAMENTS[k]) {
              TOURNAMENTS[k] = {
                players: [],
                matches: [],
                stats: new Map(),
                meta: {},
                matchType: "Singles",
                teams: [],
              };
            }
            TOURNAMENTS[k].matchType = TOURNAMENTS[k].matchType || "Singles";
            return TOURNAMENTS[k];
          }

          function updateGenderVisibility() {
            if (!categorySelect) return;
            const show = /^U\d+$/i.test(categorySelect.value);
            if (genderLabel)
              genderLabel.style.display = show ? "inline-block" : "none";
            if (genderSelect)
              genderSelect.style.display = show ? "inline-block" : "none";
          }
          function updateKeyTag() {
            if (currentKeyTag)
              currentKeyTag.textContent = `Now editing: ${getKey()}`;
          }

          try {
            const lastKey = localStorage.getItem("lastCategoryKey");
            if (lastKey && categorySelect && genderSelect) {
              const idx = lastKey.indexOf("-");
              if (idx > 0) {
                const cat = lastKey.slice(0, idx);
                const sub = lastKey.slice(idx + 1);
                if (categorySelect.querySelector(`option[value="${cat}"]`))
                  categorySelect.value = cat;
                if (sub && genderSelect.querySelector(`option[value="${sub}"]`))
                  genderSelect.value = sub;
              } else if (
                categorySelect.querySelector(`option[value="${lastKey}"]`)
              )
                categorySelect.value = lastKey;
            }
          } catch (e) {}

          updateGenderVisibility();
          updateKeyTag();

          on(categorySelect, "change", () => {
            saveDB();
            updateGenderVisibility();
            try {
              localStorage.setItem("lastCategoryKey", getKey());
            } catch {}
            updateKeyTag();
            maybeAutoBuild();
            renderAll();
          });
          on(genderSelect, "change", () => {
            saveDB();
            try {
              localStorage.setItem("lastCategoryKey", getKey());
            } catch {}
            updateKeyTag();
            maybeAutoBuild();
            renderAll();
          });

          function openDB() {
            return new Promise((resolve, reject) => {
              const req = indexedDB.open(DB_NAME, 1);
              req.onupgradeneeded = (e) => {
                db = e.target.result;
                if (!db.objectStoreNames.contains(DB_STORE)) {
                  db.createObjectStore(DB_STORE);
                }
              };
              req.onsuccess = (e) => {
                db = e.target.result;
                resolve(db);
              };
              req.onerror = (e) => reject(e);
            });
          }

          function saveDB() {
            if (!db) return;
            const out = {};
            for (const [k, v] of Object.entries(TOURNAMENTS)) {
              out[k] = {
                players: v.players,
                matches: v.matches,
                teams: v.teams || [],
                stats: Object.fromEntries(v.stats || {}),
                meta: v.meta || {},
                matchType: v.matchType || "Singles",
              };
            }
            try {
              const tx = db.transaction(DB_STORE, "readwrite");
              tx.objectStore(DB_STORE).put(JSON.stringify(out), "data");
              tx.oncomplete = () => console.log("Saved to DB");
            } catch (e) {
              console.warn("saveDB failed", e);
            }
          }

          function loadDB() {
            return new Promise((resolve) => {
              if (!db) return resolve();
              try {
                const tx = db.transaction(DB_STORE, "readonly");
                const req = tx.objectStore(DB_STORE).get("data");
                req.onsuccess = (e) => {
                  if (e.target.result) {
                    try {
                      const parsed = JSON.parse(e.target.result);
                      for (const [k, v] of Object.entries(parsed)) {
                        TOURNAMENTS[k] = {
                          players: v.players || [],
                          matches: v.matches || [],
                          stats: new Map(Object.entries(v.stats || {})),
                          meta: v.meta || {},
                          matchType: v.matchType || "Singles",
                          teams: v.teams || [],
                        };
                      }
                    } catch (err) {}
                  }
                  resolve();
                };
                req.onerror = () => resolve();
              } catch (err) {
                resolve();
              }
            });
          }

          function getCategoryIndex() {
            return categories.indexOf(getKey());
          }
          function setCategoryByIndex(i) {
            if (i < 0 || i >= categories.length) return;
            const parts = categories[i].split("-");
            const cat = parts[0];
            const gen = parts[1] || "";
            if (categorySelect) categorySelect.value = cat;
            if (gen && genderSelect) genderSelect.value = gen;
            updateGenderVisibility();
            updateKeyTag();
            try {
              localStorage.setItem("lastCategoryKey", getKey());
            } catch {}
            maybeAutoBuild();
            renderAll();
          }
          on(q("prevCategoryBtn"), "click", () => {
            const i = getCategoryIndex();
            if (i > 0) setCategoryByIndex(i - 1);
          });
          on(q("nextCategoryBtn"), "click", () => {
            const i = getCategoryIndex();
            if (i < categories.length - 1) setCategoryByIndex(i + 1);
          });

          on(togglePlayersBtn, "click", () => {
            if (playerSidebar) playerSidebar.classList.add("active");
            const so = document.getElementById("sidebarOverlay");
            if (so) so.classList.add("active");
          });
          on(document.getElementById("sidebarOverlay"), "click", () => {
            if (playerSidebar) playerSidebar.classList.remove("active");
            const so = document.getElementById("sidebarOverlay");
            if (so) so.classList.remove("active");
          });

          on(addBtn, "click", async () => {
            if (!playerName) return;
            const v = playerName.value.trim();
            if (!v) return;
            const st = getState();
            st.players.push({
              name: v,
              id: "",
              aadhar: "",
              age: "",
              country: "",
              bio: "",
              video: "",
              photo: "",
            });
            try {
              const playerObj = {
                id: crypto.randomUUID(),
                name: v,
                age: 0,
                aadhar: "",
                country: "",
                state: "",
                district: "",
                category: categorySelect ? categorySelect.value : "",
                hand: "N/A",
                photo: "",
              };
              const dbg = await openGlobalDB();
              dbg
                .transaction("players", "readwrite")
                .objectStore("players")
                .put(playerObj);
              try {
                new BroadcastChannel("tournament-sync").postMessage({
                  type: "playerAdded",
                  player: playerObj,
                });
              } catch (e) {}
            } catch (e) {
              console.warn("openGlobalDB failure", e);
            }
            if (playerName) playerName.value = "";
            renderPlayersSidebar();
            updateCount();
            saveDB();
          });

          on(bulkBtn, "click", async () => {
            if (!bulk) return;
            const names = bulk.value
              .split(/\r?\n|,/)
              .map((s) => s.trim())
              .filter(Boolean);
            if (!names.length) return;
            const st = getState();
            for (const n of names) {
              st.players.push({
                name: n,
                id: "",
                aadhar: "",
                age: "",
                country: "",
                bio: "",
                video: "",
                photo: "",
              });
              try {
                const playerObj = {
                  id: crypto.randomUUID(),
                  name: n,
                  age: 0,
                  aadhar: "",
                  country: "",
                  state: "",
                  district: "",
                  category: categorySelect ? categorySelect.value : "",
                  hand: "N/A",
                  photo: "",
                };
                const dbg = await openGlobalDB();
                dbg
                  .transaction("players", "readwrite")
                  .objectStore("players")
                  .put(playerObj);
                try {
                  new BroadcastChannel("tournament-sync").postMessage({
                    type: "playerAdded",
                    player: playerObj,
                  });
                } catch (e) {}
              } catch (e) {
                console.warn("bulk openGlobalDB failed", e);
              }
            }
            bulk.value = "";
            renderPlayersSidebar();
            updateCount();
            saveDB();
          });

          on(clearBtn, "click", () => {
            const st = getState();
            if (!st.players.length) {
              alert("No players to clear.");
              return;
            }
            if (
              !confirm(
                "Are you sure you want to remove all players and matches for this category?"
              )
            )
              return;
            st.players = [];
            st.matches = [];
            st.stats = new Map();
            st.teams = [];
            renderAll();
            saveDB();
          });

          function updateCount() {
            const st = getState();
            if (count)
              count.textContent = `${st.players.length} player${
                st.players.length === 1 ? "" : "s"
              }`;
            saveDB();
          }

          on(q("resetAllBtn"), "click", () => {
            if (!confirm("Reset all match scores for ALL categories?")) return;
            for (const [k, st] of Object.entries(TOURNAMENTS)) {
              (st.matches || []).forEach((m) => {
                m.sa = "";
                m.sb = "";
                m.saved = false;
              });
              st.stats = new Map();
            }
            renderAll();
            saveDB();
          });

          on(q("clearAllBtn"), "click", () => {
            if (!confirm("Clear ALL players and matches from ALL categories?"))
              return;
            for (const [k, st] of Object.entries(TOURNAMENTS)) {
              st.players = [];
              st.matches = [];
              st.stats = new Map();
              st.teams = [];
            }
            renderAll();
            saveDB();
          });

          function renderPlayersSidebar() {
            const st = getState();
            if (!playerList) return;
            playerList.innerHTML = "";
            st.players.forEach((p, i) => {
              const card = document.createElement("div");
              card.className = "player-card";
              const img = document.createElement("img");
              img.src = p.photo || "default.png";
              const info = document.createElement("div");
              info.className = "player-info";
              const nm = document.createElement("div");
              nm.className = "player-name";
              nm.textContent = p.name || "(no name)";
              const meta = document.createElement("div");
              meta.className = "player-meta";
              const s = getStatsFor(p.name);
              meta.textContent = `P:${s.P} ‚Ä¢ W:${s.W} ‚Ä¢ L:${s.L}`;
              info.appendChild(nm);
              info.appendChild(meta);
              const del = document.createElement("button");
              del.className = "player-del";
              del.textContent = "‚ùå";
              del.onclick = (e) => {
                e.stopPropagation();
                if (!confirm(`Delete ${p.name || "this player"}?`)) return;
                st.players.splice(i, 1);
                st.matches = st.matches.filter(
                  (m) =>
                    m.a !== p.name &&
                    m.b !== p.name &&
                    !(m.a && m.a.includes(p.name)) &&
                    !(m.b && m.b.includes(p.name))
                );
                recomputeStats();
                renderAll();
                saveDB();
              };
              card.appendChild(img);
              card.appendChild(info);
              card.appendChild(del);
              card.onclick = () => openPlayerPopup(st.players[i], i);
              playerList.appendChild(card);
            });
          }

          function generateRoundRobin(names) {
            const arr = names.slice();
            if (arr.length < 2) return [];
            if (arr.length % 2 === 1) arr.push("BYE");
            const rounds = [];
            const n = arr.length;
            const half = n / 2;
            const fixed = arr[0];
            let rest = arr.slice(1);
            for (let r = 0; r < n - 1; r++) {
              const pairs = [];
              const left = [fixed, ...rest.slice(0, half - 1)];
              const right = rest.slice(half - 1).reverse();
              for (let i = 0; i < half; i++) {
                const a = left[i],
                  b = right[i];
                if (a !== "BYE" && b !== "BYE") {
                  pairs.push({
                    a,
                    b,
                    sa: "",
                    sb: "",
                    saved: false,
                    round: r + 1,
                  });
                }
              }
              rounds.push(...pairs);
              rest.unshift(rest.pop());
            }
            return rounds;
          }

          function pairAutoDoublesFromList(arr) {
            const copy = (arr || []).slice();
            const teams = [];
            for (let i = 0; i < copy.length; i += 2) {
              const p1 = copy[i];
              const p2 = copy[i + 1] || "BYE";
              teams.push(`${p1} & ${p2}`);
            }
            return teams;
          }
          function pairAutoDoubles(playersArray) {
            // playersArray is array of player objects
            const names = (playersArray || []).map((p) => p.name);
            return pairAutoDoublesFromList(names);
          }

          function maybeAutoBuild() {
            const st = getState();
            if (st.matchType === "Auto-Doubles") {
              if (
                st.players.length >= 2 &&
                (!st.matches || st.matches.length === 0)
              ) {
                st.teams = pairAutoDoubles(st.players);
                st.matches = generateRoundRobin(st.teams);
                recomputeStats();
                saveDB();
              }
            } else {
              if (st.players.length >= 2 && st.matches.length === 0) {
                st.matches = generateRoundRobin(st.players.map((p) => p.name));
                recomputeStats();
                saveDB();
              }
            }
          }

          on(buildBtn, "click", () => {
            const st = getState();
            st.matchType = matchTypeSel.value;

            // collect names optionally randomized (non-destructive)
            let names = st.players.map((p) => p.name).filter(Boolean);
            const doRandom = randomizeCheckbox && randomizeCheckbox.checked;
            if (doRandom) names = shuffleArray(names);

            if (st.matchType === "Singles") {
              if (names.length < 2) {
                alert("Add at least 2 players");
                return;
              }
              const scoreMap = new Map();
              for (const m of st.matches) {
                if (m.saved)
                  scoreMap.set(m.a + "_" + m.b, { sa: m.sa, sb: m.sb });
              }
              const newMatches = generateRoundRobin(names);
              for (const m of newMatches) {
                const key = m.a + "_" + m.b;
                if (scoreMap.has(key)) {
                  const sc = scoreMap.get(key);
                  m.sa = sc.sa;
                  m.sb = sc.sb;
                  m.saved = true;
                }
              }
              st.matches = newMatches;
              st.teams = [];
            } else if (st.matchType === "Auto-Doubles") {
              if (names.length < 2) {
                alert("Add at least 2 players");
                return;
              }

              // --- Improved logic: preserve existing teams/scores where possible ---
              const currNames = st.players.map((p) => p.name).filter(Boolean);
              const currCount = currNames.length;
              const hasOldTeams =
                Array.isArray(st.teams) && st.teams.length > 0;
              const hasMatches =
                Array.isArray(st.matches) && st.matches.length > 0;

              let teams;
              if (!hasOldTeams || !hasMatches) {
                // no previous pairing or no matches -> build fresh
                teams = pairAutoDoublesFromList(doRandom ? names : currNames);
                st.teamPlayerCount = currCount;
                st.teamMode = doRandom ? "random" : "sequential";
              } else {
                // We have previous teams & matches. Try to preserve existing pairings for players that remain.
                // Extract players that were in old teams
                const oldTeamPlayers = [];
                st.teams.forEach((t) => {
                  t.split(/\s*&\s*/).forEach((p) => {
                    if (p && p !== "BYE") oldTeamPlayers.push(p);
                  });
                });
                const newPlayers = currNames.filter(
                  (n) => !oldTeamPlayers.includes(n)
                );
                const removedPlayers = oldTeamPlayers.filter(
                  (n) => !currNames.includes(n)
                );

                const prevMode = st.teamMode || "sequential";
                const currMode = doRandom ? "random" : "sequential";

                // If nothing changed (no added/removed players AND same random/seq mode) -> reuse teams
                if (
                  newPlayers.length === 0 &&
                  removedPlayers.length === 0 &&
                  prevMode === currMode
                ) {
                  teams = st.teams;
                } else {
                  // Preserve only those teams that still have both players present
                  const preservedTeams = st.teams.filter((t) => {
                    const parts = t.split(/\s*&\s*/);
                    const p1 = parts[0];
                    const p2 = parts[1] || "BYE";
                    return (
                      currNames.includes(p1) &&
                      (p2 === "BYE" || currNames.includes(p2))
                    );
                  });

                  // Build a set of preserved players so we don't re-pair them
                  const preservedPlayersSet = new Set();
                  preservedTeams.forEach((t) => {
                    t.split(/\s*&\s*/).forEach((p) => {
                      if (p && p !== "BYE") preservedPlayersSet.add(p);
                    });
                  });

                  // Pair remaining players (newly added or previously unpaired) and append those teams
                  let playersToPair = currNames.filter(
                    (n) => !preservedPlayersSet.has(n)
                  );
                  if (doRandom) playersToPair = shuffleArray(playersToPair);
                  const newTeamsFromNewPlayers =
                    pairAutoDoublesFromList(playersToPair);
                  teams = preservedTeams.concat(newTeamsFromNewPlayers);

                  // store current team metadata
                  st.teamMode = currMode;
                  st.teamPlayerCount = currCount;
                }
              }

              // Build new round-robin matches from the (merged) teams list, but keep saved scores when possible
              const scoreMap = new Map();
              for (const m of st.matches) {
                if (m.saved)
                  scoreMap.set(m.a + "_" + m.b, { sa: m.sa, sb: m.sb });
              }
              const newMatches = generateRoundRobin(teams);
              for (const m of newMatches) {
                const key = m.a + "_" + m.b;
                if (scoreMap.has(key)) {
                  const sc = scoreMap.get(key);
                  m.sa = sc.sa;
                  m.sb = sc.sb;
                  m.saved = true;
                }
              }
              st.matches = newMatches;
              st.teams = teams; // persist merged teams
            } else {
              // Doubles manual
              let teamNames = st.players.map((p) => p.name).filter(Boolean);
              if (doRandom) teamNames = shuffleArray(teamNames);
              if (teamNames.length < 2) {
                alert("Add at least 2 teams");
                return;
              }
              const scoreMap = new Map();
              for (const m of st.matches) {
                if (m.saved)
                  scoreMap.set(m.a + "_" + m.b, { sa: m.sa, sb: m.sb });
              }
              const newMatches = generateRoundRobin(teamNames);
              for (const m of newMatches) {
                const key = m.a + "_" + m.b;
                if (scoreMap.has(key)) {
                  const sc = scoreMap.get(key);
                  m.sa = sc.sa;
                  m.sb = sc.sb;
                  m.saved = true;
                }
              }
              st.matches = newMatches;
              st.teams = teamNames;
            }

            recomputeStats();
            renderMatches();
            renderStats();
            saveDB();
          });

          on(resetBtn, "click", () => {
            const st = getState();
            if (!confirm("Reset all match scores for this tournament?")) return;
            st.matches.forEach((m) => {
              m.sa = "";
              m.sb = "";
              m.saved = false;
            });
            recomputeStats();
            renderMatches();
            renderStats();
            saveDB();
          });
          on(printBtn, "click", () => window.print());

          // Save current tournament into archive (localStorage based)
          on(q("saveFolderBtn"), "click", () => {
            const st = getState();
            let name = prompt("Enter a name for this tournament:", getKey());
            if (!name) return;
            const folderKey = `${new Date()
              .toISOString()
              .slice(0, 10)}_${name}`;
            localStorage.setItem(
              "folder_" + folderKey,
              JSON.stringify({ all: archive })
            );
            renderFolders();
          });
          on(q("saveAllBtn"), "click", () => {
            let name = prompt(
              "Enter a name for this archive of all tournaments:",
              "all_tournaments"
            );
            if (!name) return;
            const folderKey = `${name}`;

            // Copy everything from TOURNAMENTS
            const archive = {};
            for (const [k, st] of Object.entries(TOURNAMENTS)) {
              archive[k] = {
                players: st.players,
                matches: st.matches,
                teams: st.teams || [],
                stats: Object.fromEntries(st.stats || []),
                meta: st.meta || {},
                matchType: st.matchType || "Singles",
              };
            }

            localStorage.setItem(
              "folder_" + folderKey,
              JSON.stringify({ all: archive })
            );
            renderFolders();
          });

          on(q("folderToggle"), "click", () => {
            const list = q("folderList");
            if (!list) return;
            if (list.style.display === "none" || !list.style.display) {
              list.style.display = "block";
              q("folderToggle").textContent = "üìÇ Saved Tournaments ‚ñæ";
            } else {
              list.style.display = "none";
              q("folderToggle").textContent = "üìÇ Saved Tournaments ‚ñ∏";
            }
          });

          // Render folder list
          function renderFolders() {
            const ul = q("folderList");
            ul.innerHTML = "";
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key.startsWith("folder_")) {
                keys.push(key.replace("folder_", ""));
              }
            }
            keys.sort(); // keep them ordered by name/date
            keys.forEach((folderKey) => {
              const li = document.createElement("li");
              li.innerHTML = `
      <span onclick="toggleFolderPopup('${folderKey}')">${folderKey}</span>
      <button onclick="confirmDeleteFolder('${folderKey}')">‚ùå</button>
    `;
              ul.appendChild(li);
            });
          }

          window.toggleFolderPopup = (folderKey) => {
            const popup = q("folderPopup");
            if (
              popup.style.display === "block" &&
              popup.dataset.key === folderKey
            ) {
              popup.style.display = "none";
              return;
            }

            const data = localStorage.getItem("folder_" + folderKey);
            if (!data) return;
            const parsed = JSON.parse(data);

            popup.dataset.key = folderKey;
            popup.style.display = "block";
            popup.style.top = "50%";
            popup.style.left = "50%";
            popup.style.transform = "translate(-50%, -50%)";
            q("popupTitle").textContent = folderKey;

            if (parsed.all) {
              // multi-category archive
              q("popupContent").innerHTML = `<p>Contains ${
                Object.keys(parsed.all).length
              } categories</p>`;
              // load all immediately
              for (const [k, v] of Object.entries(parsed.all)) {
                TOURNAMENTS[k] = JSON.parse(JSON.stringify(v));
                TOURNAMENTS[k].stats = new Map(Object.entries(v.stats || {}));
                TOURNAMENTS[k].matchType = v.matchType || "Singles"; // restore match type
              }
              // üîë Fix: Set dropdown based on the active category (e.g. Batch1)
              const activeKey = getKey();
              const activeState = TOURNAMENTS[activeKey];
              if (matchTypeSel && activeState) {
                matchTypeSel.value = activeState.matchType || "Singles";
              }
              renderAll();
              renderAllStats();
            } else {
              // single category archive (old style)
              q("popupContent").innerHTML = `
  <p><b>Players:</b> ${parsed.players.map((p) => p.name).join(", ")}</p>
  <p><b>Matches:</b> ${parsed.matches.length}</p>
`;

              TOURNAMENTS[getKey()] = JSON.parse(JSON.stringify(parsed));

              // üîë restore matchType into state
              TOURNAMENTS[getKey()].matchType = parsed.matchType || "Singles";

              // üîë also update dropdown so UI matches the loaded state
              if (matchTypeSel) {
                matchTypeSel.value = TOURNAMENTS[getKey()].matchType;
              }

              renderAll();
              renderStats();
              renderAllStats();
            }
          };

          // Popup open
          window.openFolderPopup = (folderKey) => {
            const data = localStorage.getItem("folder_" + folderKey);
            if (!data) return;
            const parsed = JSON.parse(data);

            const popup = q("folderPopup");
            const title = q("popupTitle");
            const body = q("popupContent");
            if (title) title.textContent = folderKey;
            if (body) {
              body.innerHTML = `
      <p><b>Players:</b> ${parsed.players.map((p) => p.name).join(", ")}</p>
      <button onclick="loadFolder('${folderKey}')">Load Tournament</button>
    `;
            }
            if (popup) popup.style.display = "block";
          };
          window.confirmDeleteFolder = (folderKey) => {
            if (confirm(`Delete saved tournament "${folderKey}"?`)) {
              localStorage.removeItem("folder_" + folderKey);
              renderFolders();
              closeFolderPopup();
            }
          };

          // Close popup
          window.closeFolderPopup = () => {
            const popup = q("folderPopup");
            if (popup) popup.style.display = "none";
          };

          // Load tournament fully
          window.loadFolder = (folderKey) => {
            const data = localStorage.getItem("folder_" + folderKey);
            if (!data) return;
            const parsed = JSON.parse(data);
            // deep copy so archive untouched
            TOURNAMENTS[getKey()] = JSON.parse(JSON.stringify(parsed));
            renderAll();
            closeFolderPopup();
          };

          // Delete only from archives
          window.deleteFolder = (folderKey) => {
            localStorage.removeItem("folder_" + folderKey);
            renderFolders();
          };

          // --- Make popup draggable ---
          (function makePopupDraggable() {
            const popup = q("folderPopup");
            const header = popup?.querySelector(".popup-header");
            if (!popup || !header) return;

            let offsetX = 0,
              offsetY = 0,
              dragging = false;

            // Mouse events
            header.addEventListener("mousedown", (e) => {
              dragging = true;
              offsetX = e.clientX - popup.offsetLeft;
              offsetY = e.clientY - popup.offsetTop;
            });
            document.addEventListener("mousemove", (e) => {
              if (!dragging) return;
              popup.style.left = e.clientX - offsetX + "px";
              popup.style.top = e.clientY - offsetY + "px";
            });
            document.addEventListener("mouseup", () => {
              dragging = false;
            });

            // Touch events
            header.addEventListener("touchstart", (e) => {
              dragging = true;
              const t = e.touches[0];
              offsetX = t.clientX - popup.offsetLeft;
              offsetY = t.clientY - popup.offsetTop;
            });
            document.addEventListener(
              "touchmove",
              (e) => {
                if (!dragging) return;
                const t = e.touches[0];
                popup.style.left = t.clientX - offsetX + "px";
                popup.style.top = t.clientY - offsetY + "px";
                e.preventDefault(); // prevent page scroll while dragging
              },
              { passive: false }
            );
            document.addEventListener("touchend", () => {
              dragging = false;
            });
          })();

          // Export / Import
          function exportAllData() {
            try {
              const dataOut = {};
              for (const [k, v] of Object.entries(TOURNAMENTS)) {
                dataOut[k] = {
                  players: v.players,
                  matches: v.matches,
                  teams: v.teams || [],
                  meta: v.meta || {},
                  matchType: v.matchType || "Singles",
                  stats: Object.fromEntries(v.stats || {}),
                };
              }
              const dataStr = JSON.stringify(dataOut, null, 2);
              const blob = new Blob([dataStr], { type: "application/json" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              const fname = `tournaments_export_${new Date()
                .toISOString()
                .slice(0, 19)
                .replace(/[:T]/g, "_")}.json`;
              a.download = fname;
              document.body.appendChild(a);
              a.click();
              a.remove();
              setTimeout(() => URL.revokeObjectURL(url), 5000);
            } catch (e) {
              alert(
                "Export failed: " + (e && e.message ? e.message : String(e))
              );
            }
          }
          on(exportBtn, "click", exportAllData);

          on(importBtn, "click", () => {
            if (importFile) importFile.click();
          });
          if (importFile) {
            importFile.addEventListener("change", (ev) => {
              const f = ev.target.files && ev.target.files[0];
              if (!f) return;
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const parsed = JSON.parse(e.target.result);
                  if (typeof parsed !== "object" || parsed === null) {
                    throw new Error("Invalid format");
                  } // merge
                  for (const [k, v] of Object.entries(parsed)) {
                    // coerce shapes
                    const players = Array.isArray(v.players)
                      ? v.players.map((p) =>
                          typeof p === "string" ? { name: p } : p
                        )
                      : [];
                    const matches = Array.isArray(v.matches) ? v.matches : [];
                    const teams = Array.isArray(v.teams) ? v.teams : [];
                    const matchType = v.matchType || "Singles";
                    const stats =
                      v.stats && typeof v.stats === "object"
                        ? new Map(Object.entries(v.stats))
                        : new Map();
                    TOURNAMENTS[k] = {
                      players,
                      matches,
                      teams,
                      meta: v.meta || {},
                      matchType,
                      stats,
                    };
                  }
                  saveDB();
                  renderAll();
                  alert("Import complete");
                  importFile.value = "";
                } catch (err) {
                  console.error("Import error", err);
                  alert(
                    "Invalid import file: " +
                      (err && err.message ? err.message : String(err))
                  );
                  importFile.value = "";
                }
              };
              reader.readAsText(f);
            });
          }

          function renderMatches() {
            const st = getState();
            if (matchesTitle)
              matchesTitle.textContent = `Matches ‚Äî ${getKey()} (${
                st.matchType || "Singles"
              })`;
            const tbl = matchesTable;
            if (!tbl) return;
            tbl.innerHTML = "";
            if (!st.matches || !st.matches.length) {
              tbl.innerHTML =
                '<tr><td>No matches. Click "Generate Matches".</td></tr>';
              return;
            }
            const byRound = new Map();
            for (const m of st.matches) {
              if (!byRound.has(m.round)) byRound.set(m.round, []);
              byRound.get(m.round).push(m);
            }
            let html = `<tr><th style="text-align:left">S.No</th><th style="text-align:left">Round</th><th style="text-align:left">Match</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">Save</th></tr>`;
            let idx = 1;
            for (const [rnd, arr] of [...byRound.entries()].sort(
              (a, b) => a[0] - b[0]
            )) {
              html += `<tr class="round-header"><td colspan="6">Round ${rnd}</td></tr>`;
              for (const m of arr) {
                const rowId = `m_${rnd}_${idx}`;
                html += `
                <tr data-row="${rowId}">
                  <td>${idx}</td>
                  <td>R${rnd}</td>
                  <td>${esc(m.a)} vs ${esc(m.b)}</td>
                  <td style="text-align:center"><input type="number" min="0" step="1" data-a value="${
                    m.sa ?? ""
                  }" ${m.saved ? "disabled" : ""}></td>
                  <td style="text-align:center"><input type="number" min="0" step="1" data-b value="${
                    m.sb ?? ""
                  }" ${m.saved ? "disabled" : ""}></td>
                  <td style="text-align:center"><button class="btn" data-save ${
                    m.saved ? "disabled" : ""
                  }>Save</button></td>
                </tr>
              `;
                idx++;
              }
            }
            tbl.innerHTML = html;
            let rowIdx = 0;
            for (const [rnd, arr] of [...byRound.entries()].sort(
              (a, b) => a[0] - b[0]
            )) {
              for (const m of arr) {
                const tr = tbl.querySelectorAll("tr[data-row]")[rowIdx];
                if (!tr) {
                  rowIdx++;
                  continue;
                }
                const inA = tr.querySelector("input[data-a]");
                const inB = tr.querySelector("input[data-b]");
                const btn = tr.querySelector("button[data-save]");
                if (!btn) {
                  rowIdx++;
                  continue;
                }
                btn.onclick = () => {
                  const a = (inA?.value || "").toString().trim();
                  const b = (inB?.value || "").toString().trim();
                  if (a === "" || b === "") {
                    alert("Enter both scores");
                    return;
                  }
                  const na = parseInt(a, 10),
                    nb = parseInt(b, 10);
                  if (Number.isNaN(na) || Number.isNaN(nb)) {
                    alert("Scores must be numbers");
                    return;
                  }
                  if (na === nb) {
                    alert("No ties allowed");
                    return;
                  }
                  m.sa = na;
                  m.sb = nb;
                  m.saved = true;
                  if (inA) inA.disabled = true;
                  if (inB) inB.disabled = true;
                  btn.disabled = true;
                  recomputeStats();
                  renderStats();
                  renderAllStats();
                  saveDB();
                };
                rowIdx++;
              }
            }
          }

          function getStatsFor(name) {
            const st = getState();
            return st.stats.get(name) || { P: 0, W: 0, L: 0, PF: 0, PA: 0 };
          }

          function recomputeStats() {
            const st = getState();
            st.stats = new Map();
            if (st.matchType === "Auto-Doubles" || st.matchType === "Doubles") {
              const teams =
                st.teams && st.teams.length
                  ? st.teams
                  : pairAutoDoubles(st.players || []);
              for (const t of teams)
                st.stats.set(t, { P: 0, W: 0, L: 0, PF: 0, PA: 0 });
              for (const m of st.matches || []) {
                if (!m.saved) continue;
                const a = st.stats.get(m.a);
                const b = st.stats.get(m.b);
                if (!a || !b) continue;
                a.P++;
                b.P++;
                a.PF += m.sa;
                a.PA += m.sb;
                b.PF += m.sb;
                b.PA += m.sa;
                if (m.sa > m.sb) {
                  a.W++;
                  b.L++;
                } else {
                  b.W++;
                  a.L++;
                }
              }
            } else {
              for (const p of st.players)
                st.stats.set(p.name, { P: 0, W: 0, L: 0, PF: 0, PA: 0 });
              for (const m of st.matches || []) {
                if (!m.saved) continue;
                const a = st.stats.get(m.a);
                const b = st.stats.get(m.b);
                if (!a || !b) continue;
                a.P++;
                b.P++;
                a.PF += m.sa;
                a.PA += m.sb;
                b.PF += m.sb;
                b.PA += m.sa;
                if (m.sa > m.sb) {
                  a.W++;
                  b.L++;
                } else {
                  b.W++;
                  a.L++;
                }
              }
            }
          }

          function renderStats() {
            const st = getState();
            if (!statsBody) return;
            const rows = [...st.stats.entries()]
              .map(([name, s]) => ({ name, ...s }))
              .sort(
                (x, y) =>
                  y.W - x.W || y.PF - y.PA - (x.PF - x.PA) || y.PF - x.PF
              );
            statsBody.innerHTML = "";
            rows.forEach((r, i) => {
              const tr = document.createElement("tr");
              tr.innerHTML = `<td>${i + 1}</td><td>${esc(r.name)}</td><td>${
                r.P
              }</td><td class="win">${r.W}</td><td class="loss">${
                r.L
              }</td><td>${r.PF}</td><td>${r.PA}</td><td>${r.PF - r.PA}</td>`;
              statsBody.appendChild(tr);
            });
          }

          function renderAllStats() {
            const body = document.getElementById("allStatsBody");
            if (!body) return;
            body.innerHTML = "";
            for (const [catKey, data] of Object.entries(TOURNAMENTS)) {
              if (!data.players || !data.players.length) continue;
              const stats = new Map();
              if (
                data.matchType === "Auto-Doubles" ||
                data.matchType === "Doubles"
              ) {
                const teams =
                  data.teams && data.teams.length
                    ? data.teams
                    : pairAutoDoubles(data.players);
                for (const t of teams)
                  stats.set(t, { P: 0, W: 0, L: 0, PF: 0, PA: 0 });
                for (const m of data.matches || []) {
                  if (!m.saved) continue;
                  const a = stats.get(m.a);
                  const b = stats.get(m.b);
                  if (!a || !b) continue;
                  a.P++;
                  b.P++;
                  a.PF += m.sa;
                  a.PA += m.sb;
                  b.PF += m.sb;
                  b.PA += m.sa;
                  if (m.sa > m.sb) {
                    a.W++;
                    b.L++;
                  } else {
                    b.W++;
                    a.L++;
                  }
                }
              } else {
                for (const p of data.players)
                  stats.set(p.name, { P: 0, W: 0, L: 0, PF: 0, PA: 0 });
                for (const m of data.matches || []) {
                  if (!m.saved) continue;
                  const a = stats.get(m.a);
                  const b = stats.get(m.b);
                  if (!a || !b) continue;
                  a.P++;
                  b.P++;
                  a.PF += m.sa;
                  a.PA += m.sb;
                  b.PF += m.sb;
                  b.PA += m.sa;
                  if (m.sa > m.sb) {
                    a.W++;
                    b.L++;
                  } else {
                    b.W++;
                    a.L++;
                  }
                }
              }
              const header = document.createElement("tr");
              header.className = "category-header";
              header.innerHTML = `<td colspan="9">${catKey} ‚Äî ${
                data.matchType || "Singles"
              }</td>`;
              body.appendChild(header);
              const rows = [...stats.entries()]
                .map(([name, s]) => ({ name, ...s }))
                .sort(
                  (x, y) =>
                    y.W - x.W || y.PF - y.PA - (x.PF - x.PA) || y.PF - x.PF
                );
              rows.forEach((r, i) => {
                const tr = document.createElement("tr");
                tr.className = "category-group";
                tr.innerHTML = `<td></td><td>${i + 1}</td><td>${
                  r.name
                }</td><td>${r.P}</td><td class="win">${
                  r.W
                }</td><td class="loss">${r.L}</td><td>${r.PF}</td><td>${
                  r.PA
                }</td><td>${r.PF - r.PA}</td>`;
                body.appendChild(tr);
              });
            }
          }

          async function renderGlobalPlayers() {
            const list = document.getElementById("globalPlayerList");
            if (!list) return;
            list.innerHTML = "";
            try {
              const dbg = await openGlobalDB();
              const tx = dbg.transaction("players", "readonly");
              const req = tx.objectStore("players").getAll();
              req.onsuccess = () => {
                req.result.forEach((p, i) => {
                  const div = document.createElement("div");
                  div.className = "player-card";
                  div.innerHTML = `<img src="${
                    p.photo || "default.png"
                  }" /><div>${p.name} ${
                    p.category ? "‚Äî " + p.category : ""
                  }</div>`;
                  div.onclick = () => openPlayerPopup(p, i);
                  list.appendChild(div);
                });
              };
            } catch (e) {
              /* ignore */
            }
          }

          function renderAll() {
            renderPlayersSidebar();
            updateCount();
            renderMatches();
            renderStats();
            renderAllStats();
            renderGlobalPlayers();
            saveDB();
          }

          openDB()
            .then(() => loadDB())
            .then(() => {
              const st = getState();

              // Restore last match type (default to Singles only if nothing saved)
              if (matchTypeSel) {
                matchTypeSel.value = st.matchType ? st.matchType : "Singles";

                // Keep state in sync when user changes dropdown
                matchTypeSel.addEventListener("change", () => {
                  const s = getState();
                  s.matchType = matchTypeSel.value; // persist selection
                  saveDB();
                });
              }

              maybeAutoBuild();
              renderAll();
              renderFolders();
            })
            .catch((err) => {
              console.warn("DB init failed", err);
            });

          window.renderAll = renderAll;

          // sample
          on(sampleBtn, "click", () => {
            const st = getState();
            st.players = [
              { name: "Alice" },
              { name: "Bob" },
              { name: "Charlie" },
              { name: "David" },
              { name: "Eve" },
            ];
            st.matches = [];
            st.teams = [];
            st.stats = new Map();
            renderAll();
            alert("Sample players loaded ‚Äî click Generate Matches");
          });

          // Popup helpers
          window.openPlayerPopup = function (player, index) {
            const popup = document.getElementById("playerPopup");
            if (!popup) return;
            popup.style.display = "flex";
            const pn = document.getElementById("popupName");
            const pa = document.getElementById("popupAge");
            const pc = document.getElementById("popupCountry");
            const pad = document.getElementById("popupAadhar");
            const pb = document.getElementById("popupBio");
            const photo = document.getElementById("popupPhoto");
            if (pn) pn.value = player.name || "";
            if (pa) pa.value = player.age || "";
            if (pc) pc.value = player.country || "";
            if (pad) pad.value = player.aadhar || "";
            if (pb) pb.value = player.bio || "";
            if (photo) photo.src = player.photo || "default.png";
            const saveBtn = document.getElementById("popupSaveBtn");
            if (saveBtn)
              saveBtn.onclick = () => {
                player.name = (
                  document.getElementById("popupName")?.value || ""
                ).trim();
                player.age = (
                  document.getElementById("popupAge")?.value || ""
                ).trim();
                player.country = (
                  document.getElementById("popupCountry")?.value || ""
                ).trim();
                player.aadhar = (
                  document.getElementById("popupAadhar")?.value || ""
                ).trim();
                player.bio = (
                  document.getElementById("popupBio")?.value || ""
                ).trim();
                renderAll();
                window.closePlayerPopup();
              };
          };
          window.closePlayerPopup = function () {
            const popup = document.getElementById("playerPopup");
            if (!popup) return;
            popup.style.display = "none";
          };
        } catch (err) {
          console.error("Initialization error", err);
        }

        // Tab switching + hide header behavior (deferred, defensive)
        try {
          const menuBtns = document.querySelectorAll("#menuTabs button") || [];
          if (menuBtns.length) {
            menuBtns.forEach((btn) => {
              btn.addEventListener("click", () => {
                const target = btn.getAttribute("data-tab");
                document.querySelectorAll(".tabContent").forEach((tab) => {
                  tab.style.display = "none";
                });
                document
                  .querySelectorAll("#menuTabs button")
                  .forEach((b) => b.classList.remove("active"));
                const tgt = document.getElementById(target);
                if (tgt) tgt.style.display = "block";
                btn.classList.add("active");
                const toggleHeaderBtn =
                  document.getElementById("toggleHeaderBtn");
                if (toggleHeaderBtn) {
                  if (target === "tournamentTab") {
                    toggleHeaderBtn.style.display = "block";
                  } else {
                    toggleHeaderBtn.style.display = "none";
                  }
                }
              });
            });
          }

          const toggleHeaderBtn = document.getElementById("toggleHeaderBtn");
          if (toggleHeaderBtn) {
            toggleHeaderBtn.addEventListener("click", () => {
              const header = document.querySelector("#tournamentTab > header");
              if (!header) return;
              if (header.classList.contains("hidden")) {
                header.classList.remove("hidden");
                toggleHeaderBtn.textContent = "Hide Header";
              } else {
                header.classList.add("hidden");
                toggleHeaderBtn.textContent = "Show Header";
              }
            });
          }

          const playerPopupEl = document.getElementById("playerPopup");
          if (playerPopupEl) {
            playerPopupEl.addEventListener("click", (e) => {
              if (e.target.id === "playerPopup") {
                window.closePlayerPopup();
              }
            });
          }
        } catch (err) {
          console.warn("UI wiring failed", err);
        }
      })();
    </script>
  </body>
</html>
